(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{170:function(t,a,_){"use strict";_.r(a);var r=_(0),v=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"find-a-job"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#find-a-job","aria-hidden":"true"}},[t._v("#")]),t._v(" find-a-job")]),t._v(" "),_("h3",{attrs:{id:"javascript"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript","aria-hidden":"true"}},[t._v("#")]),t._v(" javascript")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("静态资源优化，webRTC，布局，")])]),t._v(" "),_("li",[_("p",[t._v("http 状态码")])]),t._v(" "),_("li",[_("p",[t._v("node / golang 并发区别")])])]),t._v(" "),_("p",[t._v("node 使用的是单线程异步处理模式，golang支持多线程处理")]),t._v(" "),_("p",[t._v("golang - 协程")]),t._v(" "),_("p",[t._v("又称微线程，在单线程上执行多个任务，用函数切换，开销极小。不通过操作系统调度，没有进程、线程的切换开销。genvent，monkey.patchall")]),t._v(" "),_("p",[t._v("多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("redux\n状态机，对象存储，React Component -> Action -> Store -> (Component) -> Reducers.")])]),t._v(" "),_("li",[_("p",[t._v("闭包\n读取内部变量，回调，封装变量。")])]),t._v(" "),_("li",[_("p",[t._v("原型链\n所有函数都有 prototype，所有对象都有 __proto__，contrustor 指向 prototype，__proto__ 可以一直指到 null。")])]),t._v(" "),_("li",[_("p",[t._v("并发")])])]),t._v(" "),_("p",[t._v("并发是轮流处理多个任务的能力 / 任务队列，并行是同时处理多个任务。this")]),t._v(" "),_("p",[t._v("js 是单线程的(一个主线程和任务队列，为了避免复杂性)，html5 web worker 允许 js 创建多个线程，但子线程受主线程控制，并不能操作 DOM，异步 -> 任务队列(event loop -> 回调函数)，")]),t._v(" "),_("ul",[_("li",[t._v("进程")])]),t._v(" "),_("p",[t._v("cpu 调度分派的基本单位，有单独的地址空间。一个进程至少有一个线程，线程没有独立地址空间，并发性高。")]),t._v(" "),_("h3",{attrs:{id:"react"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[t._v("#")]),t._v(" react")]),t._v(" "),_("ul",[_("li",[t._v("redux 使用")]),t._v(" "),_("li",[t._v("生命周期及原理")]),t._v(" "),_("li",[t._v("MVVC")]),t._v(" "),_("li",[t._v("MVC")])]),t._v(" "),_("h3",{attrs:{id:"rust"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rust","aria-hidden":"true"}},[t._v("#")]),t._v(" Rust")]),t._v(" "),_("ul",[_("li",[t._v("线程锁")]),t._v(" "),_("li",[t._v("Rust Ownership")]),t._v(" "),_("li",[t._v("mut")])]),t._v(" "),_("h3",{attrs:{id:"数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据库")]),t._v(" "),_("ul",[_("li",[t._v("SQL 多种查询办法")])]),t._v(" "),_("h3",{attrs:{id:"运维类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运维类","aria-hidden":"true"}},[t._v("#")]),t._v(" 运维类")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Docker 的使用")])]),t._v(" "),_("li",[_("p",[t._v("shell script")])]),t._v(" "),_("li",[_("p",[t._v("指针地址\n地址是字节编号，一串 16进制数字；指针是保存地址的变量。")])])]),t._v(" "),_("h3",{attrs:{id:"网络层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络层","aria-hidden":"true"}},[t._v("#")]),t._v(" 网络层")]),t._v(" "),_("ul",[_("li",[t._v("tcp / udp 原理\n1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。\n2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。\n3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。\n4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。")])])])}],!1,null,null,null);a.default=v.exports}}]);